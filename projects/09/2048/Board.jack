// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/09/Board/Board.jack

/** Implements a graphical board. */
class Board {

   field int nrows, ncols;
   field Array grid;

   /** Constructs a new board with a given number of rows and columns. */
   constructor Board new(int Arows, int Acols) {
      var int i, j;
      var Array row;

      let nrows = Arows;
      let ncols = Acols;
      let grid = Array.new(nrows);

      let i = 0;
      while (i < nrows) {
         let row = Array.new(ncols);
         let j = 0;
         while (j < ncols) {
            let grid[i] = row;
            let row[j] = Block.new();
            let j = j + 1;
         }
         let i = i + 1;
      }
      return this;
   }

   method int getNrows() {
      return nrows;
   }

   method int getNcols() {
      return ncols;
   }

   /** Get Block at row r, column c. */
   method Block getBlockAt(int r, int c) {
      var Array row;
      var Block block;

      let row = grid[r];
      let block = row[c];
      return block;
   }

   /** Set value v to block at position r, c. */
   method void setBlock(int v, int r, int c) {
      var Block block;
      let block = getBlockAt(r, c);
      do block.setValue(v);
      return;
   }

   /** Populate board. */
   method void populate() {
      var Array rows, cols;
      var int i;

      let rows = Array.new(4);
      let cols = Array.new(4);

      let rows[0] = 1;
      let rows[1] = 2;
      let rows[2] = 1;
      let rows[3] = 2;

      let cols[0] = 0;
      let cols[1] = 1;
      let cols[2] = 2;
      let cols[3] = 3;

      while (i < 4) {
         do setBlock(2, rows[i], cols[i]);
         let i = i + 1;
      }

      return;
   }

   /** Initialize board. */
   method void initialize() {
      return;
   }

   /** Alter board by moving. Return an updated copy of the board. */
   method Board alter(int direction) {
      var Board board_new;

      if (direction = 1) { let board_new = alterLeft(); }
      if (direction = 2) { let board_new = alterUp(); }
      if (direction = 3) { let board_new = alterRight(); } // might need to update in opposite direction
      if (direction = 4) { let board_new = alterDown(); }

      return board_new;
   }

   method Board alterLeft() {
      var Board board_new;
      var Array row_new;
      var Block block, block_new;
      var int r, c, c_new;
      var boolean moved;

      let board_new = Board.new(nrows, ncols);

      let c = 0;
      while (c < ncols) {
         let r = 0;
         while (r < nrows) {
            let block = getBlockAt(r, c);
            let moved = false;
            if (~block.isEmpty()) {
               let c_new = 0;
               // see if it can move left
               while ((c_new < c) & (~moved)) {
                  let block_new = board_new.getBlockAt(r, c_new);
                  if (block_new.isEmpty()) {
                     do block_new.setValue(block.getValue());
                     let moved = true;
                  }
                  else {
                     if (block_new.getValue() = block.getValue()) {
                        do block_new.setValue(block.getValue() * 2);
                        let moved = true;
                     }
                  }
                  let c_new = c_new + 1;
               }
               // if can't move, stay
               if (~moved) {
                  let block_new = board_new.getBlockAt(r, c_new);
                  do block_new.setValue(block.getValue());
                  let moved = true;
               }
            }
            let r = r + 1;
         }
         let c = c + 1;
      }
      return board_new;
   }

   method Board alterUp() {
      var Board board_new;
      var Array row_new;
      var Block block, block_new;
      var int r, c, r_new;
      var boolean moved;

      let board_new = Board.new(nrows, ncols);

      let r = 0;
      while (r < nrows) {
         let c = 0;
         while (c < ncols) {
            let block = getBlockAt(r, c);
            let moved = false;
            if (~block.isEmpty()) {
               let r_new = 0;
               // see if it can move up
               while ((r_new < r) & (~moved)) {
                  let block_new = board_new.getBlockAt(r_new, c);
                  if (block_new.isEmpty()) {
                     do block_new.setValue(block.getValue());
                     let moved = true;
                  }
                  else {
                     if (block_new.getValue() = block.getValue()) {
                        do block_new.setValue(block.getValue() * 2);
                        let moved = true;
                     }
                  }
                  let r_new = r_new + 1;
               }
               // if can't move, stay
               if (~moved) {
                  let block_new = board_new.getBlockAt(r_new, c);
                  do block_new.setValue(block.getValue());
                  let moved = true;
               }
            }
            let c = c + 1;
         }
         let r = r + 1;
      }
      return board_new;
   }

   method Board alterRight() {
      var Board board_new;
      var Array row_new;
      var Block block, block_new;
      var int r, c, c_new;
      var boolean moved;

      let board_new = Board.new(nrows, ncols);

      let c = ncols - 1;
      while (c > -1) {
         let r = ncols - 1;
         while (r > -1) {
            let block = getBlockAt(r, c);
            let moved = false;
            if (~block.isEmpty()) {
               let c_new = ncols - 1;
               // see if it can move right
               while ((c_new > c) & (~moved)) {
                  let block_new = board_new.getBlockAt(r, c_new);
                  if (block_new.isEmpty()) {
                     do block_new.setValue(block.getValue());
                     let moved = true;
                  }
                  else {
                     if (block_new.getValue() = block.getValue()) {
                        do block_new.setValue(block.getValue() * 2);
                        let moved = true;
                     }
                  }
                  let c_new = c_new - 1;
               }
               // if can't move, stay
               if (~moved) {
                  let block_new = board_new.getBlockAt(r, c_new);
                  do block_new.setValue(block.getValue());
                  let moved = true;
               }
            }
            let r = r - 1;
         }
         let c = c - 1;
      }
      return board_new;
   }

   method Board alterDown() {
      var Board board_new;
      var Array row_new;
      var Block block, block_new;
      var int r, c, r_new;
      var boolean moved;

      let board_new = Board.new(nrows, ncols);

      let r = nrows - 1;
      while (r > -1) {
         let c = nrows - 1;
         while (c > -1) {
            let block = getBlockAt(r, c);
            let moved = false;
            if (~block.isEmpty()) {
               let r_new = nrows - 1;
               // see if it can move up
               while ((r_new > r) & (~moved)) {
                  let block_new = board_new.getBlockAt(r_new, c);
                  if (block_new.isEmpty()) {
                     do block_new.setValue(block.getValue());
                     let moved = true;
                  }
                  else {
                     if (block_new.getValue() = block.getValue()) {
                        do block_new.setValue(block.getValue() * 2);
                        let moved = true;
                     }
                  }
                  let r_new = r_new - 1;
               }
               // if can't move, stay
               if (~moved) {
                  let block_new = board_new.getBlockAt(r_new, c);
                  do block_new.setValue(block.getValue());
                  let moved = true;
               }
            }
            let c = c - 1;
         }
         let r = r - 1;
      }
      return board_new;
   }

   method boolean isEmptyAt(int r, int c) {
      var Block block;
      let block = getBlockAt(r, c);
      return block.isEmpty();
   }

   /** Disposes this board. */
   method void dispose() {
      var Array row;
      var Block block;
      var int r, c;

      let r = 0;
      while (r < nrows) {
         let row = grid[r];
         let c = 0;
         while (c < ncols) {
            let block = row[c];
            do block.dispose();
            let c = c + 1;
         }
         do row.dispose();
         let r = r + 1;
      }
      do grid.dispose();


      do Memory.deAlloc(this);
      return;
   }

   /** Print a blank space c times.
       Helper for Board.print() below. */
   function void printOffset(int c) {
      var int ci;

      let ci = 0;
      while (ci < c) {
         do Output.printString(" ");
         let ci = ci + 1;
      }
      
      return;
   }

   /** Draws the board on the screen. */
   method void print() {
      var int rOffset, cOffset;
      var int r, c, p, CHAR_WIDTH;
      var Block currBlock;
      var String wall;

      let rOffset = 4;
      let cOffset = 10;

      // Set starting point for cursor
      do Output.moveCursor(rOffset, 0);
      do Board.printOffset(cOffset);
      
      let CHAR_WIDTH = (Block.getMaxLength() + 3) * ncols + 1;
      let wall = String.new(CHAR_WIDTH);

      // Make wall for separating rows
      let p = 0;
      while (p < CHAR_WIDTH) {
         do wall.appendChar(45);  // "-"
         let p = p + 1;
      }

      let r = 0;
      while (r < nrows) {
         do Output.printString(wall);
         do Output.println();      // New line
         do Board.printOffset(cOffset);
         do Output.printString("| ");
         let c = 0;
         while (c < ncols) {
            let currBlock = getBlockAt(r, c);
            do currBlock.print();
            do Output.printString(" | ");
            let c = c + 1;
         }
         do Output.println();      // New line
         do Board.printOffset(cOffset);

         let r = r + 1;
      }
      do Output.printString(wall);
      do Output.println();      // New line
      do Board.printOffset(cOffset);

      return;
   }



}
